From 71a6bff8656a1713615ffdd9139a83d65ba46c6d Mon Sep 17 00:00:00 2001
From: Hauke Mehrtens <hauke@hauke-m.de>
Date: Sat, 3 May 2014 22:54:59 +0200
Subject: [PATCH 02/17] bcm47xx-nvram: add new broadcom nvram driver with dt
 support

This adds a new driver which searches at a given memory range for a
nvram like it is used on the bcm47xx and bcm53xx SoCs with ARM and MIPS
CPUs. This driver provides acces to this nvram to other device in the
device tree. You have to specify the memory ranges where the content of
the flash chip is memory mapped and this driver will search there for
some nvram and parse it. Other drivers can use this driver to access the
device nvram. The nvram is used to store board configurations like the
mac addresses, the switch configuration and the calibration data for
the wifi devices.

This was copied from arch/mips/bcm47xx/nvram.c and modified to interact
with device tree. My plan is to make the MIPS bcm47xx also use this new
driver some time later.

Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
---
 .../devicetree/bindings/misc/bcm47xx-nvram.txt     |  19 ++
 arch/mips/bcm47xx/board.c                          |  40 ++--
 arch/mips/bcm47xx/nvram.c                          |   7 +-
 arch/mips/bcm47xx/setup.c                          |   4 +-
 arch/mips/bcm47xx/sprom.c                          |   4 +-
 arch/mips/bcm47xx/time.c                           |   2 +-
 drivers/misc/Kconfig                               |   5 +
 drivers/misc/Makefile                              |   1 +
 drivers/misc/bcm47xx-nvram.c                       | 215 +++++++++++++++++++++
 drivers/net/ethernet/broadcom/b44.c                |   2 +-
 drivers/net/ethernet/broadcom/bgmac.c              |   5 +-
 drivers/ssb/driver_chipcommon_pmu.c                |   3 +-
 include/linux/bcm47xx_nvram.h                      |  17 +-
 13 files changed, 286 insertions(+), 38 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/misc/bcm47xx-nvram.txt
 create mode 100644 drivers/misc/bcm47xx-nvram.c

--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/bcm47xx-nvram.txt
@@ -0,0 +1,19 @@
+Broadcom bcm47xx/bcm53xx nvram access driver
+
+This driver provides access to the nvram for other drivers.
+
+Required properties:
+
+- compatible : brcm,bcm47xx-nvram
+
+- reg : iomem address range
+
+On NorthStar ARM SoCs the NAND flash is available at 0x1c000000 and the
+NOR flash is at 0x1e000000
+
+Example:
+
+nvram0: nvram@0 {
+	compatible = "brcm,bcm47xx-nvram";
+	reg = <0x1c000000 0x01000000>;
+};
--- a/arch/mips/bcm47xx/board.c
+++ b/arch/mips/bcm47xx/board.c
@@ -196,50 +196,50 @@ static __init const struct bcm47xx_board
 	const struct bcm47xx_board_type_list2 *e2;
 	const struct bcm47xx_board_type_list3 *e3;
 
-	if (bcm47xx_nvram_getenv("model_name", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "model_name", buf1, sizeof(buf1)) >= 0) {
 		for (e1 = bcm47xx_board_list_model_name; e1->value1; e1++) {
 			if (!strcmp(buf1, e1->value1))
 				return &e1->board;
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("model_no", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "model_no", buf1, sizeof(buf1)) >= 0) {
 		for (e1 = bcm47xx_board_list_model_no; e1->value1; e1++) {
 			if (strstarts(buf1, e1->value1))
 				return &e1->board;
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("machine_name", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "machine_name", buf1, sizeof(buf1)) >= 0) {
 		for (e1 = bcm47xx_board_list_machine_name; e1->value1; e1++) {
 			if (strstarts(buf1, e1->value1))
 				return &e1->board;
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("hardware_version", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "hardware_version", buf1, sizeof(buf1)) >= 0) {
 		for (e1 = bcm47xx_board_list_hardware_version; e1->value1; e1++) {
 			if (strstarts(buf1, e1->value1))
 				return &e1->board;
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("productid", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "productid", buf1, sizeof(buf1)) >= 0) {
 		for (e1 = bcm47xx_board_list_productid; e1->value1; e1++) {
 			if (!strcmp(buf1, e1->value1))
 				return &e1->board;
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("ModelId", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "ModelId", buf1, sizeof(buf1)) >= 0) {
 		for (e1 = bcm47xx_board_list_ModelId; e1->value1; e1++) {
 			if (!strcmp(buf1, e1->value1))
 				return &e1->board;
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("melco_id", buf1, sizeof(buf1)) >= 0 ||
-	    bcm47xx_nvram_getenv("buf1falo_id", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "melco_id", buf1, sizeof(buf1)) >= 0 ||
+	    bcm47xx_nvram_getenv(NULL, "buf1falo_id", buf1, sizeof(buf1)) >= 0) {
 		/* buffalo hardware, check id for specific hardware matches */
 		for (e1 = bcm47xx_board_list_melco_id; e1->value1; e1++) {
 			if (!strcmp(buf1, e1->value1))
@@ -247,8 +247,8 @@ static __init const struct bcm47xx_board
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("boot_hw_model", buf1, sizeof(buf1)) >= 0 &&
-	    bcm47xx_nvram_getenv("boot_hw_ver", buf2, sizeof(buf2)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "boot_hw_model", buf1, sizeof(buf1)) >= 0 &&
+	    bcm47xx_nvram_getenv(NULL, "boot_hw_ver", buf2, sizeof(buf2)) >= 0) {
 		for (e2 = bcm47xx_board_list_boot_hw; e2->value1; e2++) {
 			if (!strcmp(buf1, e2->value1) &&
 			    !strcmp(buf2, e2->value2))
@@ -256,16 +256,16 @@ static __init const struct bcm47xx_board
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("board_id", buf1, sizeof(buf1)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "board_id", buf1, sizeof(buf1)) >= 0) {
 		for (e1 = bcm47xx_board_list_board_id; e1->value1; e1++) {
 			if (!strcmp(buf1, e1->value1))
 				return &e1->board;
 		}
 	}
 
-	if (bcm47xx_nvram_getenv("boardtype", buf1, sizeof(buf1)) >= 0 &&
-	    bcm47xx_nvram_getenv("boardnum", buf2, sizeof(buf2)) >= 0 &&
-	    bcm47xx_nvram_getenv("boardrev", buf3, sizeof(buf3)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "boardtype", buf1, sizeof(buf1)) >= 0 &&
+	    bcm47xx_nvram_getenv(NULL, "boardnum", buf2, sizeof(buf2)) >= 0 &&
+	    bcm47xx_nvram_getenv(NULL, "boardrev", buf3, sizeof(buf3)) >= 0) {
 		for (e3 = bcm47xx_board_list_board; e3->value1; e3++) {
 			if (!strcmp(buf1, e3->value1) &&
 			    !strcmp(buf2, e3->value2) &&
@@ -286,7 +286,7 @@ void __init bcm47xx_board_detect(void)
 		return;
 
 	/* check if the nvram is available */
-	err = bcm47xx_nvram_getenv("boardtype", buf, sizeof(buf));
+	err = bcm47xx_nvram_getenv(NULL, "boardtype", buf, sizeof(buf));
 
 	/* init of nvram failed, probably too early now */
 	if (err == -ENXIO) {
--- a/arch/mips/bcm47xx/nvram.c
+++ b/arch/mips/bcm47xx/nvram.c
@@ -158,7 +158,8 @@ static int nvram_init(void)
 	return -ENXIO;
 }
 
-int bcm47xx_nvram_getenv(char *name, char *val, size_t val_len)
+int bcm47xx_nvram_getenv(const struct device *dev, const char *name, char *val,
+			 size_t val_len)
 {
 	char *var, *value, *end, *eq;
 	int err;
@@ -190,7 +191,7 @@ int bcm47xx_nvram_getenv(char *name, cha
 }
 EXPORT_SYMBOL(bcm47xx_nvram_getenv);
 
-int bcm47xx_nvram_gpio_pin(const char *name)
+int bcm47xx_nvram_gpio_pin(const struct device *dev, const char *name)
 {
 	int i, err;
 	char nvram_var[10];
@@ -200,7 +201,7 @@ int bcm47xx_nvram_gpio_pin(const char *n
 		err = snprintf(nvram_var, sizeof(nvram_var), "gpio%i", i);
 		if (err <= 0)
 			continue;
-		err = bcm47xx_nvram_getenv(nvram_var, buf, sizeof(buf));
+		err = bcm47xx_nvram_getenv(dev, nvram_var, buf, sizeof(buf));
 		if (err <= 0)
 			continue;
 		if (!strcmp(name, buf))
--- a/arch/mips/bcm47xx/setup.c
+++ b/arch/mips/bcm47xx/setup.c
@@ -123,7 +123,7 @@ static int bcm47xx_get_invariants(struct
 	memset(&iv->sprom, 0, sizeof(struct ssb_sprom));
 	bcm47xx_fill_sprom(&iv->sprom, NULL, false);
 
-	if (bcm47xx_nvram_getenv("cardbus", buf, sizeof(buf)) >= 0)
+	if (bcm47xx_nvram_getenv(NULL, "cardbus", buf, sizeof(buf)) >= 0)
 		iv->has_cardbus_slot = !!simple_strtoul(buf, NULL, 10);
 
 	return 0;
@@ -146,7 +146,7 @@ static void __init bcm47xx_register_ssb(
 		panic("Failed to initialize SSB bus (err %d)", err);
 
 	mcore = &bcm47xx_bus.ssb.mipscore;
-	if (bcm47xx_nvram_getenv("kernel_args", buf, sizeof(buf)) >= 0) {
+	if (bcm47xx_nvram_getenv(NULL, "kernel_args", buf, sizeof(buf)) >= 0) {
 		if (strstr(buf, "console=ttyS1")) {
 			struct ssb_serial_port port;
 
--- a/arch/mips/bcm47xx/sprom.c
+++ b/arch/mips/bcm47xx/sprom.c
@@ -50,10 +50,10 @@ static int get_nvram_var(const char *pre
 
 	create_key(prefix, postfix, name, key, sizeof(key));
 
-	err = bcm47xx_nvram_getenv(key, buf, len);
+	err = bcm47xx_nvram_getenv(NULL, key, buf, len);
 	if (fallback && err == -ENOENT && prefix) {
 		create_key(NULL, postfix, name, key, sizeof(key));
-		err = bcm47xx_nvram_getenv(key, buf, len);
+		err = bcm47xx_nvram_getenv(NULL, key, buf, len);
 	}
 	return err;
 }
--- a/arch/mips/bcm47xx/time.c
+++ b/arch/mips/bcm47xx/time.c
@@ -61,7 +61,7 @@ void __init plat_time_init(void)
 	}
 
 	if (chip_id == 0x5354) {
-		len = bcm47xx_nvram_getenv("clkfreq", buf, sizeof(buf));
+		len = bcm47xx_nvram_getenv(NULL, "clkfreq", buf, sizeof(buf));
 		if (len >= 0 && !strncmp(buf, "200", 4))
 			hz = 100000000;
 	}
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -515,6 +515,11 @@ config SRAM
 	  the genalloc API. It is supposed to be used for small on-chip SRAM
 	  areas found on many SoCs.
 
+config BCM47XX_NVRAM
+	tristate "BCM47XX nvram driver"
+	help
+		This adds support for the brcm47xx nvram driver.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -54,3 +54,4 @@ obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lat
 obj-$(CONFIG_SRAM)		+= sram.o
 obj-y				+= mic/
 obj-$(CONFIG_GENWQE)		+= genwqe/
+obj-$(CONFIG_BCM47XX_NVRAM)	+= bcm47xx-nvram.o
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@ -411,7 +411,7 @@ static void b44_wap54g10_workaround(stru
 	 * see https://dev.openwrt.org/ticket/146
 	 * check and reset bit "isolate"
 	 */
-	if (bcm47xx_nvram_getenv("boardnum", buf, sizeof(buf)) < 0)
+	if (bcm47xx_nvram_getenv(NULL, "boardnum", buf, sizeof(buf)) < 0)
 		return;
 	if (simple_strtoul(buf, NULL, 0) == 2) {
 		err = __b44_readphy(bp, 0, MII_BMCR, &val);
--- a/drivers/net/ethernet/broadcom/bgmac.c
+++ b/drivers/net/ethernet/broadcom/bgmac.c
@@ -974,7 +974,8 @@ static void bgmac_chip_reset(struct bgma
 			     BGMAC_CHIPCTL_1_IF_TYPE_MII;
 		char buf[4];
 
-		if (bcm47xx_nvram_getenv("et_swtype", buf, sizeof(buf)) > 0) {
+		if (bcm47xx_nvram_getenv(NULL, "et_swtype", buf,
+					 sizeof(buf)) > 0) {
 			if (kstrtou8(buf, 0, &et_swtype))
 				bgmac_err(bgmac, "Failed to parse et_swtype (%s)\n",
 					  buf);
@@ -1534,7 +1535,7 @@ static int bgmac_probe(struct bcma_devic
 	}
 
 	bgmac->int_mask = BGMAC_IS_ERRMASK | BGMAC_IS_RX | BGMAC_IS_TX_MASK;
-	if (bcm47xx_nvram_getenv("et0_no_txint", NULL, 0) == 0)
+	if (bcm47xx_nvram_getenv(NULL, "et0_no_txint", NULL, 0) == 0)
 		bgmac->int_mask &= ~BGMAC_IS_TX_MASK;
 
 	/* TODO: reset the external phy. Specs are needed */
--- a/drivers/ssb/driver_chipcommon_pmu.c
+++ b/drivers/ssb/driver_chipcommon_pmu.c
@@ -319,7 +319,8 @@ static void ssb_pmu_pll_init(struct ssb_
 
 	if (bus->bustype == SSB_BUSTYPE_SSB) {
 		char buf[20];
-		if (bcm47xx_nvram_getenv("xtalfreq", buf, sizeof(buf)) >= 0)
+		if (bcm47xx_nvram_getenv(NULL, "xtalfreq", buf,
+					 sizeof(buf)) >= 0)
 			crystalfreq = simple_strtoul(buf, NULL, 0);
 	}
 
--- a/include/linux/bcm47xx_nvram.h
+++ b/include/linux/bcm47xx_nvram.h
@@ -15,18 +15,23 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 
-#ifdef CONFIG_BCM47XX
-int bcm47xx_nvram_getenv(const char *name, char *val, size_t val_len);
+struct device;
 
-int bcm47xx_nvram_gpio_pin(const char *name);
+#if defined(CONFIG_BCM47XX) || defined(CONFIG_BCM47XX_NVRAM)
+int bcm47xx_nvram_getenv(const struct device *dev, const char *name, char *val,
+			 size_t val_len);
+
+int bcm47xx_nvram_gpio_pin(const struct device *dev, const char *name);
 #else
-static inline int bcm47xx_nvram_getenv(const char *name, char *val,
+static inline int bcm47xx_nvram_getenv(const struct device *dev,
+				       const char *name, char *val,
 				       size_t val_len)
 {
 	return -ENXIO;
 }
 
-static inline int bcm47xx_nvram_gpio_pin(const char *name)
+static inline int bcm47xx_nvram_gpio_pin(const struct device *dev,
+					 const char *name)
 {
 	return -ENXIO;
 }
--- a/drivers/misc/bcm47xx-nvram.c
+++ b/drivers/misc/bcm47xx-nvram.c
@@ -28,7 +28,7 @@
 
 struct nvram_header {
 	u32 magic;
-	u32 len;
+	__le32 len;
 	u32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
 	u32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
 	u32 config_ncdl;	/* ncdl values for memc */
